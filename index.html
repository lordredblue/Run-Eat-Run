<!DOCTYPE html>
<html>
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<meta name="HandheldFriendly" content="True">
	<meta name="MobileOptimized" content="320">	
    <title>Run Eat Run Test</title>
    <style>
        html,body {
            margin: 0;
            padding: 0;
            border: 0;
            overflow: hidden;
        }
        
        canvas {
            position: absolute;
            top:70px;
            bottom: 0;
            left: 0;
            right: 0;
            margin:auto;
            border: blue thin solid;
        }
        #hud  {
            
            background-color: #9AC7F9;
            opacity: 1;
            border: 4px solid black;
            align-items: center;

        }
    </style>

    <audio loop="loop" id= "audio1" autoplay onloadeddata="initialVolume()">
      <source src="runeatrundraft1.mp3"> 
      </audio>



  </head>
  <body>

    <canvas id="myCanvas" width="1000" height="750" ></canvas>

    <div id="hud">
        <table>
            <tr><td>Score:</span></td><td id = 'score'>0</td><td>High Score:</span></td><td id = 'highscore'>0</td><td><input type="button" value="Play Again" onClick="window.location.reload()"></input></td>
                <td><input type="button" value="Music" onClick="muteMusicVolume()"></input></td>
                <td><input type="button" value="Sounds" onClick="muteSoundVolume()"></input></td>
            </tr>
        </table>
    </div>

    <script type="text/javascript" src="buffer-loader.js"></script>
    <script>
        "use strict";

var GameWorld = 
{
	Width: 0,
	Height: 0,
	SizeRatio: 3,
	ViewPortX: 0,
	ViewPortY: 0,
	OutsideColor:'red',

	Initialize:function(cvs)
	{
		this.canvas = cvs;

		this.currentCanvasHeight = this.canvas.height;
		this.currentCanvasWidth = this.canvas.width;

		this.Resize();
	},
	Resize: function ()
	{
		var newH = this.SizeRatio * this.canvas.height;
		var newW = this.SizeRatio * this.canvas.width;

		if (newH != this.Height || newW != this.Width)
		{
			this.Width = newW;
			this.Height = newH;
		}
	},
	MapMouseFromCanvas: function(cx, cy)
	{
		var br = this.canvas.getBoundingClientRect();
		var x = cx-br.left + this.ViewPortX;
		var y = cy-br.top + this.ViewPortY;

		//console.log(cx, cy, x,y,br);

		return {x:x, y:y};
	},
	SetViewPortCenter: function(ctx, x, y)
	{
		ctx.fillStyle = this.OutsideColor;
		ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

		var cH = this.canvas.height/2;
		var cW = this.canvas.width/2;

		var ox = x-cW;
		var oy = y-cH;

		var newx = Math.max(-cW, ox);
		var newy = Math.max(-cH, oy);

		ctx.translate(-newx, -newy);

		this.ViewPortX = newx;
		this.ViewPortY = newy;
	}
};

var musicVolume;
//audioctx
var AudioContext = window.AudioContext || window.webkitAudioContext;
var audioCtx = new AudioContext();

var flee;
var chase;
var eat;

var isSoundPlaying;
var playSound=false;

var bufferLoader = new BufferLoader(
    audioCtx,
    [
    "fleesound.mp3",
    "chasesound.mp3",
    "eatsound.mp3",
    ],
    finishedLoading
    );

bufferLoader.load();

function initialVolume() {
    var myAudio = document.getElementById("audio1");  
    if(localStorage.getItem('musicVolume')){   
        myAudio.volume = localStorage.getItem('musicVolume'); 
    }
    else {
        myAudio.volume = 0.1; 
        localStorage.setItem('musicVolume',.1);
    }
};

function muteMusicVolume() {
  var myAudio = document.getElementById("audio1"); 
  if  (myAudio.volume > 0){
    myAudio.volume = 0;
    localStorage.setItem('musicVolume',0);
}
else {
   myAudio.volume = .1;
   localStorage.setItem('musicVolume',.1);
}
};

function muteSoundVolume() {
    if(playSound===false)
    {
        playSound=true;
        localStorage.setItem('isSoundPlaying',true);
    }
    else{
        playSound=false;
        localStorage.setItem('isSoundPlaying',false);
        flee.gainNode.gain.value=0;
        chase.gainNode.gain.value=0;
        eat.gainNode.gain.value=0;
    }
};

var mousex;
var mousey;
var canvas = document.getElementById("myCanvas");
canvas.style.background = 'white';
canvas.addEventListener('mousemove', function(event){
	var m = GameWorld.MapMouseFromCanvas(event.clientX, event.clientY);

    mousex = m.x;
    mousey = m.y;
});
var ctx = canvas.getContext("2d");

function finishedLoading(bufferList) {
    // Create three sources and buffers
    var fleesoundsource = audioCtx.createBufferSource();
    var chasesoundsource = audioCtx.createBufferSource();
    var eatsoundsource = audioCtx.createBufferSource();
    fleesoundsource.buffer = bufferList[0];
    chasesoundsource.buffer = bufferList[1];
    eatsoundsource.buffer = bufferList[2];
    flee= new AudioPath(fleesoundsource);
    chase=new AudioPath(chasesoundsource);
    eat=new AudioPath(eatsoundsource);
    flee.gainNode.gain.value=0;
    chase.gainNode.gain.value=0;
    eat.gainNode.gain.value=0;

    if(localStorage.getItem('isSoundPlaying')){
        playSound=('true' ===localStorage.getItem('isSoundPlaying'));
    }
    else
    {
        playSound=true;
        localStorage.setItem('isSoundPlaying',true);
    }
};

var AudioPath = function(bs){

    this.bufferSource = audioCtx.createBufferSource();
    this.bufferSource = bs;
    this.bufferSource.loop=true;


    this.gainNode = audioCtx.createGain();
    this.gainNode.connect(audioCtx.destination);

    this.panner = audioCtx.createPanner();
    this.bufferSource.connect(this.panner);
    this.panner.connect(this.gainNode);

    this.gainNode.gain.value = 0;
    this.bufferSource.start();

    this.panner.panningModel = 'HRTF';
    this.panner.distanceModel = 'inverse';
    this.panner.refDistance = 5;
    this.panner.maxDistance = 10000;
    this.panner.rolloffFactor = 1;
    this.panner.coneInnerAngle = 360;
    this.panner.coneOuterAngle = 0;
    this.panner.coneOuterGain = 0;

    if(this.panner.orientationX) {
      this.panner.orientationX.value = 1;
      this.panner.orientationY.value = 0;
      this.panner.orientationZ.value = 0;
  } else {
      this.panner.setOrientation(1,0,0);
  }
};

var ratio=16/9; //aspect ratio for canvas size
var player_size = 30;
var robot_size = player_size; //fair game
var robot_speed = 2.5;//main speed magnitude

//sum of players and robots should be 4!
var player_count = 1;
var robot_count = 5;

var maxNumShapes=90;
var minNumShapes=60;
var numShapes = getRandomIntInclusive(minNumShapes,maxNumShapes);

var player = undefined;
var robots = [];
var shapes = [];


//Shape sizes
var maxsize = 20;
var minsize = 15;
var maxspeed = 0;
var minspeed = 0;
var spinSpeed = 250;

//highscore
var highscore;

function getRandomColor() {
    var letters = '0123456789ABCDEF';
    var color = '#';
    for (var i = 0; i < 6; i++ ) {
        color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
}


function updateScore(integer){
    document.getElementById("score").innerHTML = integer;
}

function updateHighScore(integer){

    if(localStorage.getItem('highscore'))
    {
        var oldhighscore=parseInt(localStorage.getItem('highscore'));
        if (oldhighscore<integer)
        {
            localStorage.setItem('highscore',integer);
            document.getElementById("highscore").innerHTML = integer;
        }
        else{
            document.getElementById("highscore").innerHTML = oldhighscore;
        }

    }
    else {

        highscore=integer;
        localStorage.setItem('highscore',integer);
        document.getElementById("highscore").innerHTML = integer;
    }
};

var Point = function (x,y) {
    this.x=x;
    this.y=y;
};

//Shape object
var Shape = function(x,y,size,color,speedx,speedy,isPlayer,type){
    console.log("Shape created");
    this.x = x;
    this.y = y;
    this.size = size;
    this.color = color;
    this.type = type;
    this.isPlayer=isPlayer;
    this.speedx=speedx;
    this.speedy=speedy;
    this.shapesEaten = 0;
    
    this.points = []; 
    
    var minSides=2;
    var maxSides=6;        

    this.sides= getRandomIntInclusive(minSides,maxSides);
    if (this.sides==2) {
        this.sides=0;
    }

    this.radarSize=this.size*3;

    if(this.isPlayer==true){
        this.listener = audioCtx.listener;

        if(this.listener.forwardX) {
          this.listener.forwardX.value = 0;
          this.listener.forwardY.value = 0;
          this.listener.forwardZ.value = -1;
          this.listener.upX.value = 0;
          this.listener.upY.value = 1;
      // this.listener.upZ.value = 0;
  } else {
      this.listener.setOrientation(0,0,-1,0,1,0);
  }
  this.listener.positionX.value = this.x;
  this.listener.positionY.value = this.y;
  this.listener.positionZ.value = 50;
}
};

function drawCircle(ctx,x,y,r,color) {
    ctx.beginPath();
    ctx.arc(x, y, r, 0, 2*Math.PI)
    ctx.fillStyle=color;
    ctx.fill();
    ctx.closePath();
}


Shape.prototype.regShape= function(ctx) {
    this.points=[];
    
//    ctx.strokeStyle = "white";
//    ctx.lineWidth = 3;


if (this.sides==0) {
    drawCircle(ctx,this.x,this.y,this.size,this.color);
} else {
    if (this.sides==3) {
        var offset=Math.PI/6
    } else if (this.sides==4) {
       var offset=Math.PI/4
   } else if (this.sides==5) {
       var offset=3*Math.PI/2
   } else if (this.sides==6) {
       var offset=Math.PI
   }

        //    x = cx + r * cos(a)
        //    y = cy + r * sin(a)

    //var circumfrence=2*Math.PI*this.size

    var deltaAngle = 2*Math.PI/this.sides;

    var currentAngle=offset;
    do {  
        var newPointX=(this.x) + (this.size*Math.cos(currentAngle));
        var newPointY=(this.y) + (this.size*Math.sin(currentAngle));

        currentAngle+=deltaAngle;

        var newPoint=new Point(newPointX,newPointY);
        this.points.push(newPoint);
    }
    while (currentAngle<=2*Math.PI+offset);


    var i=0;
        //ctx.moveTo(this.x,this.y);
        ctx.beginPath();

        while(i<this.points.length){
            ctx.lineTo(this.points[i].x,this.points[i].y);
            i++;
        }
        ctx.fillStyle = this.color;
        ctx.fill();
        
    }
    if(this.type == "player" || this.type == "robot"){
        ctx.lineWidth = this.size/15;
        ctx.strokeStyle = "black";
        ctx.stroke();
//        ctx.font = "bold "+this.size/2+"px arial";
//        var width = ctx.measureText(this.shapesEaten).width;
//        var height = ctx.measureText(this.shapesEaten).height;
//        ctx.fillText(this.shapesEaten, this.getCenter().x-(width/2), this.getCenter().y+(this.size/5));
}
};  



////Method for shape to draw itself
//Shape.prototype.draw = function(ctx) {
//    //ctx.beginPath();
//    ctx.fillStyle = this.color;
//    ctx.strokeStyle = "white";;
//    ctx.lineWidth = 3;
//    if(this.type == "square"){
//        ctx.fillRect (this.x, this.y, this.size, this.size);
//    }
//    if(this.type == "circle"){
//        ctx.beginPath();
//        ctx.arc(this.getCenter().x,this.getCenter().y,this.size/2, 0, 2 * Math.PI, false);
//        ctx.fill();
//    }
//    if(this.type == "player" || this.type == "robot"){
//        ctx.beginPath();
//        ctx.rect(this.x, this.y, this.size, this.size);
//        ctx.fill();
//        ctx.stroke();
//        ctx.closePath();
//        ctx.beginPath();
//        ctx.fillStyle = "white";
//        ctx.font = "bold "+this.size/2+"px arial";
//        var width = ctx.measureText(this.shapesEaten).width;
//        var height = ctx.measureText(this.shapesEaten).height;
//        ctx.fillText(this.shapesEaten, this.getCenter().x-(width/2), this.getCenter().y+(this.size/5));
//    }
//    //ctx.closePath();
//    //console.log("Square number " + this.id + " has been created at: "+this.x+","+ this.y);
//};

//not updated according to center
Shape.prototype.drawSpin = function(ctx) {
    //ctx.save();
    var time = new Date();
    ctx.fillStyle = this.color;
    ctx.translate((this.x + this.size/2),(this.y + this.size/2));
    ctx.rotate( ((Math.PI)/spinSpeed)*time.getMilliseconds());
    ctx.fillRect (-this.size/2, -this.size/2, this.size, this.size);
    //ctx.restore();
};

Shape.prototype.updateAudio = function(player) {
    //update audiolocation

    if(this.isPlayer){

     this.listener.setPosition(this.x,this.y,50);

 }
};

Shape.prototype.changeSize = function(ratio) {
    this.size*=ratio;
};


Shape.prototype.numShapesRegen = function(){
    return 20*numShapes/this.size;
};  

Shape.prototype.findNextMove = function(){
    var closestX;
    var closestY;
    var closestDist = -1;
    var robot = this;
    robot.targetAcquired = false;
    robot.dangerAcquired = false;
    var rangeMultiplier = 2.5;
    //var danger = undefined;

    //finding target to chase or run away from
    //checking shape locations
    shapes.forEach(function(shape){
         var dist = getDistance(shape.x,shape.y,robot.x,robot.y)-(shape.size/2);
        if(dist<=robot.size*rangeMultiplier && (dist<closestDist || closestDist==-1)){
            closestDist = dist;
            closestX = shape.x;
            closestY = shape.y;
            if(robot.size>shape.size){
                robot.targetAcquired = true;
            }
        }
    });
    
    //checking robot locations
    robots.forEach(function(robot2){
        if(robot!=robot2){
            var dist = getDistance(robot2.x,robot2.y,robot.x,robot.y);
            if(dist<=robot.size*rangeMultiplier && (dist<closestDist || closestDist==-1)){
                closestDist = dist;
                closestX = robot2.x;
                closestY = robot2.y;
                if(robot.size>robot2.size){
                    robot.targetAcquired = true;
                }
            // else if(robot.size<robot2.size){
            //     danger = robot2;
            //     robot.dangerAcquired = true;
            // }
        }
    }
});
    //checking player location
    var dist = getDistance(player.x,player.y,robot.x,robot.y);
    if(dist<=robot.size*rangeMultiplier && (dist<closestDist || closestDist==-1)){
        closestDist = dist;
        closestX = player.x;
        closestY = player.y;
        if(robot.size>player.size){
            robot.targetAcquired = true;
        }
            // else if(robot.size<player.size){
            //     danger = player;
            //     robot.dangerAcquired = true;
            // }
        }


        if(robot.targetAcquired){
        //console.log("chasing");
        var maxDist= Math.sqrt(Math.pow(GameWorld.Width,2)+Math.pow(GameWorld.Height,2));   
        var speedFactor=10*((maxDist-closestDist)/maxDist+1); // higher speedFactor means slower acceleration
        robot.x=(closestX-robot.x)/speedFactor+robot.x;
        robot.y=(closestY-robot.y)/speedFactor+robot.y;
    }
    // else if(robot.dangerAcquired){
    //     //var escapeDistance = (danger.size*rangeMultiplier+5)-closestDist;
    //     console.log("running away");
    //     var maxDist= Math.sqrt(Math.pow(canvas.width,2)+Math.pow(canvas.height,2));   
    //     var speedFactor=10*((maxDist-closestDist)/maxDist+1); // higher speedFactor means slower acceleration
    //     robot.x=(closestX-robot.x)/speedFactor-robot.x;
    //     robot.y=(closestY-robot.y)/speedFactor-robot.y;
    // }
    else{   
        //console.log("target not acquired");
        if(robot.justAte){
            //console.log("justate")
            robot.speedx*=-1;
            robot.speedy*=-1;
            robot.justAte=false;
        }
        robot.autoMove();
    }
};

Shape.prototype.run = function(shape){
    //if(shape.x<this.x && shape.y)
};

Shape.prototype.checkCollision = function(currentTime,shape2){
    var shape1 = this;
    if (getDistance(shape1.x,shape1.y,shape2.x,shape2.y)<=(shape1.size+shape2.size)/2 && shape2.inCollision==undefined){
        if (shape1.size>shape2.size){
            shape1.StartAnimation(currentTime, 500, shape1.size + shape2.size/3,1);
            shape1.shapesEaten+=1;
            shape2.speedx=0;
            shape2.speedy=0;
            shape2.inCollision = true;
            shape2.StartAnimation(currentTime, 500, 0,0);
        }
    }

};


Shape.prototype.checkRadar =function() {
  //audio on/off for radar
  var shape1=this;
  for(var i=0;i<robots.length;i++) {
    var shape2=robots[i];

    if(getDistance(shape1.x,shape1.y,shape2.x,shape2.y)<=shape1.radarSize+shape2.size/2
        || getDistance(shape1.x,shape1.y,shape2.x,shape2.y)<=(shape1.radarSize+shape2.size)/2)
    {

     if(shape1.size<shape2.size)
     {
        flee.gainNode.gain.value=1;
        flee.panner.setPosition(shape2.x,shape2.y,50);
        break;
    }

    else if(shape1.size>shape2.size)
    {
        chase.gainNode.gain.value=1;
        chase.panner.setPosition(shape2.x,shape2.y,50);
        break;
    }    
}
else {
    flee.gainNode.gain.value=0;
    chase.gainNode.gain.value=0;
}
}
};

Shape.prototype.checkCollisions = function(currentTime){
    var entity = this;
    shapes.forEach(function(shape){
        entity.checkCollision(currentTime,shape);
    });
    robots.forEach(function(robot){
        if(entity!=robot){
            entity.checkCollision(currentTime,robot);
        }
    });
    if(entity!=player){
        entity.checkCollision(currentTime,player);
    }
};

Shape.prototype.drawRadar= function(ctx){

    var now= new Date();
    var sec=now.getSeconds();

    var radarRatio=(sec%5)/10;


    this.radarSize=this.size*3*(1+radarRatio);
    ctx.beginPath()
    ctx.arc(this.x,this.y,this.radarSize,0,Math.PI*2,true);
    ctx.strokeStyle=this.color;
    ctx.stroke();
    ctx.closePath();
}

Shape.prototype.autoMove = function(){
    var shape = this;
    var time = (new Date()).getTime() - startTime;
    var newX = shape.x+(shape.speedx); // * time / 1000);
    var newY = shape.y+(shape.speedy); //* time / 1000);
    if(shape.speedx>0 && newX<(GameWorld.Width - shape.size)){
        shape.x = newX;
    }
    else if (shape.speedx>0){
        shape.speedx*=-1;
        shape.x-=1;
    }
    if(shape.speedx<0 && newX>shape.size){
        shape.x = newX;
    }
    else if (shape.speedx<0){
        shape.speedx*=-1;
        shape.x+=1;
    }
    if(shape.speedy<0 && newY>shape.size){
        shape.y = newY;
    }
    else if (shape.speedy<0){
        shape.speedy*=-1;
        shape.y+=1;
    }
    if(shape.speedy>0 && newY<(GameWorld.Height - shape.size)){
        shape.y = newY;
    }
    else if (shape.speedy>0){
        shape.speedy*=-1;
        shape.y-=1;
    }
}

Shape.prototype.IsAnimating = function() {
    return this.AnimationStartTime != undefined;
};

Shape.prototype.StartAnimation = function(time, period, newSize,newGain) {
    this.AnimationStartTime = time;
    this.AnimationStartSize = this.size;
    this.AnimationStopSize = newSize;

    this.AnimationGain=newGain;
    this.AnimationPeriod = period;
};

Shape.prototype.DoAnimation = function(time) {
    if (this.IsAnimating())
    {
        var deltaTime = time - this.AnimationStartTime;

        if (deltaTime >= this.AnimationPeriod)
            this.StopAnimation();
        else
        {
            var sizeDelta = this.AnimationStopSize - this.AnimationStartSize;

            if(playSound && this.isPlayer){

                eat.gainNode.gain.value=this.AnimationGain;
            }

            // var gainDelta= this.AnimationStopGain-this.AnimationStartGain;

            this.size = this.AnimationStartSize + sizeDelta *(deltaTime)/this.AnimationPeriod;

            // this.gainNode.gain.value=this.AnimationStartGain + gainDelta *(deltaTime)/this.AnimationPeriod;
        }
    }
};


Shape.prototype.StopAnimation = function() {
    if(playSound){
        eat.gainNode.gain.value=0;
    }
    this.size = this.AnimationStopSize;
    this.AnimationStartTime = undefined;
    this.AnimationStartSize = undefined;
    this.AnimationStopSize = undefined;
    this.AnimationPeriod = undefined;
    this.AnimationGain= undefined;
    //this.targetAcquired=false;
    this.justAte=true;
};

Shape.prototype.drain = function(){
    if (this.size>player_size) {
        var drainFactor = this.size*0.001;
        this.size-= drainFactor;
    }
};

function init() {

	GameWorld.Initialize(canvas);

    for(var i=0; i<numShapes; i++){
        var size = generateSize();
        shapes.push(new Shape(generateX(size),generateY(size),size,getRandomColor(),getRandomIntInclusive(minspeed,maxspeed),getRandomIntInclusive(minspeed,maxspeed),false,"shape"));
    }

    for(var i=0; i<robot_count; i++){
        var robot = new
        Shape(generateX(robot_size),generateY(robot_size),robot_size,getRandomColor(),0,0,false,"robot");
        if(robot.x==0){robot.speedx=robot_speed;}
        else{robot.speedx=-robot_speed;}
        if(robot.y==0){robot.speedy=robot_speed;}
        else{robot.speedy=-robot_speed;}
        robots.push(robot);
    }
    player = new Shape(generateX(player_size),generateY(player_size),player_size,getRandomColor(),0,0,true,"player");
};

function regenerateShapes(currentTime,numShapesRegen){
    if(shapes.length<numShapesRegen){
        for(var i=0; i<2; i++){
            var size = generateSize();
            shapes.push(new Shape(generateX(size),generateY(size),size,getRandomColor(),getRandomIntInclusive(minspeed,maxspeed),getRandomIntInclusive(minspeed,maxspeed),false,"shape"));    }
        }
    };

    function regenerateRobots(currentTime){
        if(robots.length<robot_count-1){

            var size= getRandomIntInclusive(player.size*.5, player.size.*1.5);

            var robot = new Shape(generateX(size),generateY(size),size,getRandomColor(),0,0,false,"robot");
            if(robot.x==0){robot.speedx=robot_speed;}
            else{robot.speedx=-robot_speed;}
            if(robot.y==0){robot.speedy=robot_speed;}
            else{robot.speedy=-robot_speed;}
            robots.push(robot);
        }
    };


// document.addEventListener("keydown", keyDownHandler, false);
// document.addEventListener("keyup", keyUpHandler, false);

// function keyDownHandler(e) {
//     if(e.keyCode == 39) {
//         rightPressed = true;
//     }
//     else if(e.keyCode == 37) {
//         leftPressed = true;
//     }
//     if(e.keyCode == 40) {
//         upPressed = true;
//     }
//     else if(e.keyCode == 38) {
//         downPressed = true;
//     }
// }

// function keyUpHandler(e) {
//     if(e.keyCode == 39) {
//         rightPressed = false;
//     }
//     else if(e.keyCode == 37) {
//         leftPressed = false;
//     }

//     if(e.keyCode == 40) {
//         upPressed = false;
//     }
//     else if(e.keyCode == 38) {
//         downPressed = false;
//     }
// }

function resize_canvas(){
    var oldCanvasWidth = canvas.width;
    var oldCanvasHeight = canvas.height;
    if (canvas.width  != window.innerWidth || canvas.height != window.innerHeight) {
        if (window.innerWidth>window.innerHeight*ratio) {
            canvas.height=window.innerHeight;
            canvas.width=canvas.height*ratio;
            var changeInWidthRatio=canvas.width/oldCanvasWidth;
            var changeInHeightRatio=canvas.height/oldCanvasHeight;
            shapes.forEach(function(shape){
                shape.x*=changeInWidthRatio;
                shape.y*=changeInHeightRatio;
                shape.changeSize(changeInHeightRatio);
            });
            player.x*=changeInWidthRatio;
            player.y*=changeInHeightRatio;
            player.changeSize(changeInHeightRatio);
            robots.forEach(function(robot){
                robot.x*=changeInWidthRatio;
                robot.y*=changeInHeightRatio;
                robot.changeSize(changeInHeightRatio);
            });            
        } else {
            canvas.width=window.innerWidth;
            canvas.height=canvas.width/ratio;
            var changeInWidthRatio=canvas.width/oldCanvasWidth;
            var changeInHeightRatio=canvas.height/oldCanvasHeight;
            shapes.forEach(function(shape){
                shape.x*=changeInWidthRatio;
                shape.y*=changeInHeightRatio;
                shape.changeSize(changeInWidthRatio);
            });
            player.x*=changeInWidthRatio;
            player.y*=changeInHeightRatio;
            player.changeSize(changeInWidthRatio);
            robots.forEach(function(robot){
                robot.x*=changeInWidthRatio;
                robot.y*=changeInHeightRatio;
                robot.changeSize(changeInWidthRatio);
            });
        }
        
        GameWorld.Resize();
    }

}

//Method to get distance between two points
function getDistance(x1,y1,x2,y2){
    return Math.sqrt(Math.pow(x1-x2,2)+Math.pow(y1-y2,2));
}

//Method to generate random X coordinate for a shape
function generateX(size){
    return Math.random() * (GameWorld.Width-size);
}

//Method to generate random Y coordinate for a shape
function generateY(size){
    return Math.random() * (GameWorld.Height-size);
}

//Method to generate random size for a shape
function generateSize(){
    return Math.random() * (maxsize - minsize) + minsize;
}

//function speed() {
    //var dist = Math.sqrt(pow(mousex-x,2)+pow(mousey-y,2));
    //return dist
//}


function update() {
   resize_canvas(); 

	ctx.resetTransform();

	//ctx.clearRect(0,0,canvas.width, canvas.height);

 	GameWorld.SetViewPortCenter(ctx, player.x, player.y);


    var currentTime = (new Date()).getTime();
 
    ctx.fillStyle = 'yellow';
    ctx.fillRect(0, 0, GameWorld.Width, GameWorld.Height);

     shapes.forEach(function(shape){
        shape.autoMove();
    });
  
   
    regenerateShapes(currentTime,player.numShapesRegen());
    regenerateRobots(currentTime);


    player.checkCollisions(currentTime);
    player.DoAnimation(currentTime);
    if(player.size==0){
        endGame(false);
        return;
    }
    
    
    for(var i=0; i<robots.length; i++){
        var robot = robots[i];
        robot.checkCollisions(currentTime);
        robot.DoAnimation(currentTime);
        if(robot.size==0){
            robots.splice(i,1);
        }
    }
    
    for(var i=0; i<shapes.length; i++){
        var shape = shapes[i];
        //shape.checkCollisions(currentTime);
        shape.DoAnimation(currentTime);
        if(shape.size==0){
            shapes.splice(i,1);
        }
    }




    for(var i=0; i<shapes.length; i++){
        var shape = shapes[i];
        shape.DoAnimation(currentTime);
        if(shape.size==0){
            shapes.splice(i,1);
        }
    }

    if (robots.length == 0) {
        endGame(true);
        return;
    }
    
    
    //dark();

    shapes.forEach(function(shape){
    //shape.draw(ctx);
    shape.regShape(ctx);
});

    robots.forEach(function(robot){
        robot.findNextMove();
        robot.drain();
    //robot.draw(ctx);
    robot.regShape(ctx);
});

    player.drain();
    //player.draw(ctx);
    player.regShape(ctx);
    //console.log(player.size)
    if(playSound){
        player.updateAudio(player);
        player.checkRadar();
    }
    player.drawRadar(ctx);


    var dist = getDistance(mousex,player.x,mousey,player.y);

    var maxDist= Math.sqrt(Math.pow(GameWorld.Width,2)+Math.pow(GameWorld.Height,2));

    var speedFactor=10*((maxDist-dist)/maxDist+1);


    if(mousex>0 && mousex<GameWorld.Width &&mousey>0 &&mousey<GameWorld.Height){
        player.x=(mousex-player.x)/speedFactor+player.x;
        player.y=(mousey-player.y)/speedFactor+player.y;
    }
    updateScore(player.shapesEaten);
    updateHighScore(player.shapesEaten);
    var speed = dist/50;

    window.requestAnimationFrame(update);
   
}


function endGame(win){
    canvas.style.background = 'black';
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.font = "30px Arial";
    ctx.textBaseline = 'middle';
    ctx.textAlign="center"; 
    //ctx.textAlign = 'center';
    ctx.fillStyle="#FFFFFF";
    if (win){
        //ctx.fillText("game over",10,50);
        ctx.fillText("YOU WON!",(canvas.width/2),(canvas.height/2-canvas.height/40));
    } else {
        //ctx.fillText("game over",10,50);
        ctx.fillText("YOU WERE EATEN!",(canvas.width/2),(canvas.height/2-canvas.height/40));
        ctx.fillText("Your Score=  "+player.shapesEaten,(canvas.width/2),(2*canvas.height/3));
    }
    shapes.forEach(function(shape){
        if (shape.source!=undefined) {
            shape.source.stop();
        }
    });
    flee.bufferSource.stop();
    chase.bufferSource.stop();
    eat.bufferSource.stop();
}

function getRandomIntInclusive(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function dark() {

    ctx.fillStyle="#000000"
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.radarSize, 0, Math.PI*2);
    ctx.closePath();
    ctx.clip();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
}

var startTime = (new Date()).getTime();
init();
window.requestAnimationFrame(update);   

</script>

</body>
</html>